int num = 5; // Declares an integer variable and assigns it the value 5.
string word = "Hello"; // Declares a string variable and assigns it the value "Hello".

Hint: Local variables usually start with a lowercase letter (camelCase) following the C#
naming convention guidelines.

If the C# compiler can infer (evaluate) the type of a variable, for example, when itis a
string literal, we can use var instead of explicitly using the variable type.

// We can use var because the compiler knows that "..." is a string
var name = "Peter";

// We can use var because we state that we create a new object of type Person.
var person = new Person();

The var keyword helps us keep the code short and improves readability.

4. Constants

Constants are immutable. Once their value is set, it can't be changed, ensuring some
data remains consistent throughout its use.

const int ConstNum = 5; // The value of 'ConstNum' will always be 5.

Hint: Constants usually start with an uppercase letter (PascalCase) following the C#
naming convention guidelines.

5. Conditional Statements

Allows you to branch your code based on conditions, making your programs dynamic.

if (condition) { /*...*/ } // Executes if 'condition' is true.
else if (condition) { /*...*/ } // Additional conditions if the above ones fail.
else { /*...*/ } // Executes if no conditions are met.

switch (variable) // Useful when comparing a single variable to many values.

{

case value1:
// Code for valuet
break; // Exits the switch statement.

C# Cheat Sheet Z T M


// ... other cases ...

default:
// Executes if no other case matches.
break;

Hint: If you don’t use break or return at the end of a switch case, the next case will also
be executed.

6. Loops

Useful for performing repetitive tasks.

for (int i = 0; i < 10; i++) { /*...*/ } // Loops 10 times, incrementing '1i' each time.
foreach (var item in collection) { /*...*/ } // Loops over each item in 'collection'.
while (condition) { /*...*/ } // Continues looping as long as 'condition' remains true.
do { /*...*/ } while (condition); // Executes once before checking ‘condition’.

7. Arrays

Fixed-size collections that hold elements of the same type.

int[] numbers = new int[5] {1, 2, 3, 4, 5}; // Declares an array of integers.

8. Lists

Like arrays, but can dynamically change in size.

using System.Collections.Generic; // Required namespace for Lists.
List<int> list = new List<int>() {1, 2, 3, 4, 5}; // Initializes a List with 5 integers.

list.Add(6); // Add the number 6 to the list
list.Remove(2) // Remove the element at index 2 (@-based) from the list.

9. Dictionaries

Associative containers that store key-value pairs.

C# Cheat Sheet Z T M


using System.Collections.Generic;
Dictionary<string, int> dict = new Dictionary<string, int>()

{

{"one", 1}, // "one" is the key, 1 is its associated value.
{"two", 2}
3;

dict .Add("key", "value"); // Add a new item to the dictionary.
dict["key"] // Access the value of the dictionary at the key 'key'.

10. Methods

Methods encapsulate logic for reuse and clarity.

public returnType MethodName(parameters) { /*...*/ } // A method's signature.

// A Sum method returning int with two int parameters.
public int Sum(int a, int b)
{

return a +b;

11. Classes & Objects

Central to object-oriented programming, classes define blueprints for objects.

public class MyClass
{

public string PropertyName { get; set; } // Properties store data for an object.
public void MethodName() { /*...*/ } // Methods define actions an object can take.

MyClass obj = new MyClass(); // Creates a new object of type 'MyClass'.

Hint: Auto-properties (as used in the example above), tell the compiler to create a
backing field. We do not have to create the backing field and fill it within the Set method
or get the value within the Get method. However, we can still implement custom logic
when required.

C# Cheat Sheet Z T M
