30. Pattern Matching

Introduced in later versions of C#, pattern matching simplifies certain programming
tasks.

object obj = "hello";
if (obj is string str)
{

Console.WriteLine(str); // str is "hello"

}

31. Local Functions

Functions can be defined within methods, allowing for encapsulation of logic without
polluting class or namespace scopes.

public void MyMethod()

{
void LocalFunction()
{
// Implementation
}
LocalFunction(); // Calling the local function
}

32. Records

Records provide a concise syntax for reference types with value semantics for equality.

They're immutable and are great for data structures.

public record Person(string Name, int Age);

Hint: We use PascalCase for the arguments because they define (public) properties
and not fields.

33. with Expressions

Used with records to create a non-destructive mutation.

C# Cheat Sheet S Z T M

11


var john = new Person("John", 30);
var jane = john with { Name = "Jane" }; // jane is now ("Jane", 30)

34. Indexers and Ranges
Allow for more flexible data access, especially useful with strings, arrays, and lists.

int[] arr = {0, 1, 2, 3, 4, 5};
var subset = arr[1..41]; // Grabs elements from index 1 to the second to last.

35. using Declaration

A more concise way to ensure IDisposable objects are properly disposed.

using var reader = new StreamReader("file.txt"); // reader is disposed of at the end of th
e enclosing scope.

36. Nullable Reference Types (NRTs)

A feature to help avoid null reference exceptions by being explicit about reference type
nullability.

#nullable enable
string? mightBeNull; // Reference type that might be null.

Hint: You can enable nullable reference types for specific parts of your .NET application
using the #nuliable pragma, as shown in the example. Or you can enable it for the
whole .NET project within the .csproj file like this: <\uilabie>enable</Nullable> .

37. Pattern-Based Using

Allows for more patterns in the using statement without implementing IDisposable.

public ref struct ResourceWrapper

{

public void Dispose()

{

C# Cheat Sheet S Z T M


// Cleanup

}

using var resource = new ResourceWrapper();

38. Property Patterns

Facilitates deconstruction of objects in pattern matching.

if (obj is Person { Name: "John", Age: var age })
{

Console.WriteLine($"John's age is {age}");

}

39. Default Interface Implementations

Interfaces can now provide default method implementations.

public interface IPerson
{
void Display();
void Greet() => Console.WriteLine("Hello!"); // Default implementation.

40. Dynamic Binding

Makes use of the DLR (Dynamic Language Runtime) for runtime type resolution.

dynamic d = 5;
d = "Hello"; // No compile-time type checking.

Additional Resources

e The C#/.NET Bootcamp course

e C# Documentation

C# Cheat Sheet S Z T M

13
